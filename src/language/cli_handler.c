#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if OS == UNIX_OS
#include <strings.h> // For the case insensitive strcasecmp() string comparison in Unix systems.
#endif

#include "char_buffer.h"
#include "cli_handler.h"
#include "compiler.h"
#include "program.h"
#include "resolver.h"
#include "vm.h"

/** 
 * Performs a strcmp on 2 strings without case sensitivity.
 * 
 * Returns exactly the same int that a strcmp would return (meaning 0 is equal).
 * Also, since it's functionally the same as strcmp, checking for length should be done outside
 * this function.
 */
static int insensitive_strcmp(const char *left, const char *right) {
#if OS == UNIX_OS
    return strcasecmp(left, right);
#elif OS == WINDOWS_OS
    return _stricmp(left, right);
#endif
}

/** Returns whether or not the passed arg matches the compared expected argument. */
static bool is_arg(const char *arg, const size_t argLength, const char *expectedArg) {
    if (argLength != strlen(expectedArg)) {
        return false;
    }
    return insensitive_strcmp(arg, expectedArg) == 0;
}

/** Sets the flag of a matching argument in CLI, erroring if it was already set. */
static void set_flag(CliHandler *cli, bool *flagPtr) {
    if (*flagPtr) {
        cli->validArgs = false;
    } else {
        *flagPtr = true;
    }
}

/** Parses one argument into the CLI, setting an error if necessary.*/
static void cli_arg(char *arg, const int argIdx, CliHandler *cli) {
    const size_t length = strlen(arg);

    if (is_arg(arg, length, "--help") || is_arg(arg, length, "-help") || is_arg(arg, length, "-h")) {
        set_flag(cli, &cli->help);
    } else if (is_arg(arg, length, "--db-token")) {
        set_flag(cli, &cli->debugTokens);
    } else if (is_arg(arg, length, "--db-ast")) {
        set_flag(cli, &cli->debugAst);
    } else if (is_arg(arg, length, "--db-bytecode")) {
        set_flag(cli, &cli->debugBytecode);
    } else if (argIdx == 1) {
        cli->file = arg; // Take 2nd argument as file name.
    } else {
        cli->validArgs = false; // If it's not the 2nd argument, then it can't be the file name.
    }
}

/** Parses all the arguments in argv for the CLI. Starts at 2nd argument to skip the exe. */
static void parse_cli(const int argc, char **argv, CliHandler *cli) {
    for (int i = 1; i < argc; i++) {
        cli_arg(argv[i], i, cli);
    }
}

/** Creates a CLI (command line interface) handler, which is returned after parsing the args. */
CliHandler create_cli_handler(const int argc, char **argv) {
    CliHandler cli = {
        .validArgs = true, .file = NULL, .exitedRepl = false,
        .help = false, .debugTokens = false, .debugAst = false, .debugBytecode = false,
        .exitCode = 0, .manuallyExited = false
    };
    parse_cli(argc, argv, &cli);
    return cli; // Returns a copy, which still has all the flags set.
}

/** Prints the documentation of the CLI. */
void print_cli_help() {
    printf("Run file: zymux <file> [options]\n");
    printf("Run REPL: zymux [options]\n");
    printf("--------------------------------\n");
    printf("options:\n");
    printf("--help | -help | -h: show help menu.\n");
    printf("--db-token: print lexed tokens.\n");
    printf("--db-ast: print abstract syntax tree.\n");
    printf("--db-bytecode: print generated bytecode.\n");
}

/** Returns an allocated string of a line that the user writes in stdin. */
char *get_stdin_line() {
    CharBuffer line = create_char_buffer();
    char ch;
    while ((ch = fgetc(stdin)) != '\r' && ch != '\n' && ch != EOF) {
        buffer_append_char(&line, ch);
    }

    // In some systems, line break is 2 characters (CRLF), so try to consume the LF if we found CR.
    if (ch == '\r') {
        ch = fgetc(stdin);
        if (ch != '\n') {
            ungetc(ch, stdin); // Wasn't LF, put it back to not cause issues.
        }
    }
    return line.text;
}

/** 
 * Compares the written REPL line with keywords that indicate exiting the REPL.
 * 
 * Returns true if the line is considered a quit keyword in the REPL, otherwise returns false.
 */
static bool line_is_quit(char *line) {
    if (
        (strlen(line) == 1 && insensitive_strcmp(line, "q") == 0)
        || (strlen(line) == 4 && insensitive_strcmp(line, "quit") == 0)
        || (strlen(line) == 4 && insensitive_strcmp(line, "exit") == 0)
    ) {
        return true;
    }
    return false;
}

/** 
 * Prompts the user for one line and runs it in REPL once.
 * 
 * returns the allocated line string so it can be stored and freed after the whole REPL session,
 * this is because the resolver needs to keep context for all REPL lines, which includes
 * storing the AST, and the AST has some tokens in its nodes whose lexemes point to whichever
 * part of the source string they come from.
 */
char *repl_line(CliHandler *cli, VulnerableObjs *vulnObjs, Resolver *resolver, Vm *vm) {
    synchronized_print(vulnObjs->program, stdout, "> ");
    char *line = get_stdin_line();
    if (line_is_quit(line)) {
        cli->exitedRepl = true;
        return line;
    }
    FuncObj *func = compile_repl_source(vulnObjs, line, resolver);
    if (func == NULL) {
        // Errors don't matter in REPL, so just reset and try again.
        return line;
    }
    ThreadObj *mainThread = get_main_thread(vm);
    mainThread->frame->func = func;
    mainThread->frame->ip = func->bytecode.data;
    interpret(vm); // Executes the main thread in the VM.

    cli->exitedRepl = cli->manuallyExited;
    return line;
}
